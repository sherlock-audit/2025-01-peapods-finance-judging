Witty Chartreuse Starling

Medium

# Swapping in _acquireBorrowTokenForRepayment is not working when the sell fee is enabled because the swap does not support fee-on-transfer tokens

### Summary

`_acquireBorrowTokenForRepayment` in the `LeverageManager` uses a swap to acquire enough tokens to repay the flash loan when leverage is removed. However, this swap does not work when a pod sell fee is enabled because fee-on-transfer tokens are not supported in this swap. This can lead to users being unable to remove their leverage.

### Root Cause

The swap in `_acquireBorrowTokenForRepayment` uses `_swapPodForBorrowToken` to swap pod tokens into paired LP tokens in order to acquire enough tokens for repaying the flash loan:
https://github.com/sherlock-audit/2025-01-peapods-finance/blob/main/contracts/contracts/lvf/LeverageManager.sol#L462-L467
For the swap, `swapV2SingleExactOut` is used on the DEX adapter, which in turn does not support fee-on-transfer tokens:
https://github.com/sherlock-audit/2025-01-peapods-finance/blob/main/contracts/contracts/dex/UniswapDexAdapter.sol#L101-L103
Uniswap provides special fee-on-transfer functions, which are used elsewhere in the protocol, but are not utilized in this swap. This means that this swap would always fail if a pod has sell fees enabled

It is important to note that there is another issue in the function that blocks the ability to transfer tokens from the user. As a result, both options for acquiring borrow tokens for the repayment are no longer possible. (see issue "Transferring of _userProvidedDebtAmtMax does not work in _acquireBorrowTokenForRepayment because _props.sender is never set, which leads to a transferFrom call from address(0), causing the transaction to revert")

### Internal Pre-conditions

1. The sell fee must not be 0

### External Pre-conditions

No external pre-conditions

### Attack Path

1. There is a pod with PEAS as the underlying token that has a sell fee
2. Alice bonds PEAS tokens in a pod
3. Alice adds leverage with the `LeverageManager`
4. Alice removes leverage, but there are not enough tokens for the repayment. As a result, an attempt is made to swap some of the pTKNs, but it fails due to the sell fee.

### Impact

This issue would render a function of the protocol unusable, making it harder for some users to remove their leverage. Additionally, this issue is exacerbated by the one mentioned above, as the alternative method to acquire the tokens also fails, leading to some users potentially being unable to remove their leverage.

### PoC

1. To execute the POC, a `POC.t.sol` file should be created in `contracts/test/POC.t.sol`.
2. The following code should be inserted into the file:
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import {console} from "forge-std/console.sol";

// forge
import {Test} from "forge-std/Test.sol";

// PEAS
import {PEAS} from "../../contracts/PEAS.sol";
import {V3TwapUtilities} from "../../contracts/twaputils/V3TwapUtilities.sol";
import {UniswapDexAdapter} from "../../contracts/dex/UniswapDexAdapter.sol";
import {IDecentralizedIndex} from "../../contracts/interfaces/IDecentralizedIndex.sol";
import {WeightedIndex} from "../../contracts/WeightedIndex.sol";
import {StakingPoolToken} from "../../contracts/StakingPoolToken.sol";
import {LendingAssetVault} from "../../contracts/LendingAssetVault.sol";
import {IndexUtils} from "../../contracts/IndexUtils.sol";
import {IIndexUtils} from "../../contracts/interfaces/IIndexUtils.sol";
import {IndexUtils} from "../contracts/IndexUtils.sol";
import {RewardsWhitelist} from "../../contracts/RewardsWhitelist.sol";
import {TokenRewards} from "../../contracts/TokenRewards.sol";

// oracles
import {ChainlinkSinglePriceOracle} from "../../contracts/oracle/ChainlinkSinglePriceOracle.sol";
import {UniswapV3SinglePriceOracle} from "../../contracts/oracle/UniswapV3SinglePriceOracle.sol";
import {DIAOracleV2SinglePriceOracle} from "../../contracts/oracle/DIAOracleV2SinglePriceOracle.sol";
import {V2ReservesUniswap} from "../../contracts/oracle/V2ReservesUniswap.sol";
import {aspTKNMinimalOracle} from "../../contracts/oracle/aspTKNMinimalOracle.sol";

// protocol fees
import {ProtocolFees} from "../../contracts/ProtocolFees.sol";
import {ProtocolFeeRouter} from "../../contracts/ProtocolFeeRouter.sol";

// autocompounding
import {AutoCompoundingPodLpFactory} from "../../contracts/AutoCompoundingPodLpFactory.sol";
import {AutoCompoundingPodLp} from "../../contracts/AutoCompoundingPodLp.sol";

// lvf
import {LeverageManager} from "../../contracts/lvf/LeverageManager.sol";

// fraxlend
import {FraxlendPairDeployer, ConstructorParams} from "./invariant/modules/fraxlend/FraxlendPairDeployer.sol";
import {FraxlendWhitelist} from "./invariant/modules/fraxlend/FraxlendWhitelist.sol";
import {FraxlendPairRegistry} from "./invariant/modules/fraxlend/FraxlendPairRegistry.sol";
import {FraxlendPair} from "./invariant/modules/fraxlend/FraxlendPair.sol";
import {VariableInterestRate} from "./invariant/modules/fraxlend/VariableInterestRate.sol";
import {IERC4626Extended} from "./invariant/modules/fraxlend/interfaces/IERC4626Extended.sol";

// flash
import {IVault} from "./invariant/modules/balancer/interfaces/IVault.sol";
import {BalancerFlashSource} from "../../contracts/flash/BalancerFlashSource.sol";
import {PodFlashSource} from "../../contracts/flash/PodFlashSource.sol";
import {UniswapV3FlashSource} from "../../contracts/flash/UniswapV3FlashSource.sol";

// uniswap-v2-core
import {UniswapV2Factory} from "v2-core/UniswapV2Factory.sol";
import {UniswapV2Pair} from "v2-core/UniswapV2Pair.sol";

// uniswap-v2-periphery
import {UniswapV2Router02} from "v2-periphery/UniswapV2Router02.sol";

// uniswap-v3-core
import {UniswapV3Factory} from "v3-core/UniswapV3Factory.sol";
import {UniswapV3Pool} from "v3-core/UniswapV3Pool.sol";

// uniswap-v3-periphery
import {SwapRouter02} from "swap-router/SwapRouter02.sol";
import {LiquidityManagement} from "v3-periphery/base/LiquidityManagement.sol";
import {PeripheryPayments} from "v3-periphery/base/PeripheryPayments.sol";
import {PoolAddress} from "v3-periphery/libraries/PoolAddress.sol";

// mocks
import {WETH9} from "./invariant/mocks/WETH.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {MockERC20} from "./invariant/mocks/MockERC20.sol";
import {TestERC20} from "./invariant/mocks/TestERC20.sol";
import {TestERC4626Vault} from "./invariant/mocks/TestERC4626Vault.sol";
import {MockV3Aggregator} from "./invariant/mocks/MockV3Aggregator.sol";
import {MockUniV3Minter} from "./invariant/mocks/MockUniV3Minter.sol";
import {MockV3TwapUtilities} from "./invariant/mocks/MockV3TwapUtilities.sol";

import {PodHelperTest} from "./helpers/PodHelper.t.sol";

contract AuditTests is PodHelperTest {
    address alice = vm.addr(uint256(keccak256("alice")));
    address bob = vm.addr(uint256(keccak256("bob")));
    address charlie = vm.addr(uint256(keccak256("charlie")));

    uint256[] internal _fraxPercentages = [10000, 2500, 7500, 5000];

    // fraxlend protocol actors
    address internal comptroller = vm.addr(uint256(keccak256("comptroller")));
    address internal circuitBreaker = vm.addr(uint256(keccak256("circuitBreaker")));
    address internal timelock = vm.addr(uint256(keccak256("comptroller")));

    uint16 internal fee = 100;
    uint256 internal PRECISION = 10 ** 27;

    uint256 donatedAmount;
    uint256 lavDeposits;

    /*///////////////////////////////////////////////////////////////
                            TEST CONTRACTS
    ///////////////////////////////////////////////////////////////*/

    PEAS internal _peas;
    MockV3TwapUtilities internal _twapUtils;
    UniswapDexAdapter internal _dexAdapter;
    LendingAssetVault internal _lendingAssetVault;
    LendingAssetVault internal _lendingAssetVault2;
    RewardsWhitelist internal _rewardsWhitelist;

    // oracles
    V2ReservesUniswap internal _v2Res;
    ChainlinkSinglePriceOracle internal _clOracle;
    UniswapV3SinglePriceOracle internal _uniOracle;
    DIAOracleV2SinglePriceOracle internal _diaOracle;
    aspTKNMinimalOracle internal _aspTKNMinOracle1Peas;
    aspTKNMinimalOracle internal _aspTKNMinOracle1Weth;

    // protocol fees
    ProtocolFees internal _protocolFees;
    ProtocolFeeRouter internal _protocolFeeRouter;

    // pods
    WeightedIndex internal _pod1Peas;

    // index utils
    IndexUtils internal _indexUtils;

    // autocompounding
    AutoCompoundingPodLpFactory internal _aspTKNFactory;
    AutoCompoundingPodLp internal _aspTKN1Peas;
    address internal _aspTKN1PeasAddress;

    // lvf
    LeverageManager internal _leverageManager;

    // fraxlend
    FraxlendPairDeployer internal _fraxDeployer;
    FraxlendWhitelist internal _fraxWhitelist;
    FraxlendPairRegistry internal _fraxRegistry;
    VariableInterestRate internal _variableInterestRate;

    FraxlendPair internal _fraxLPToken1Peas;

    // flash
    UniswapV3FlashSource internal _uniswapV3FlashSourcePeas;

    // mocks
    MockUniV3Minter internal _uniV3Minter;
    MockERC20 internal _mockDai;
    WETH9 internal _weth;
    MockERC20 internal _tokenA;
    MockERC20 internal _tokenB;
    MockERC20 internal _tokenC;

    // uniswap-v2-core
    UniswapV2Factory internal _uniV2Factory;
    UniswapV2Pair internal _uniV2Pool;

    // uniswap-v2-periphery
    UniswapV2Router02 internal _v2SwapRouter;

    // uniswap-v3-core
    UniswapV3Factory internal _uniV3Factory;
    UniswapV3Pool internal _v3peasDaiPool;
    UniswapV3Pool internal _v3peasDaiFlash;

    // uniswap-v3-periphery
    SwapRouter02 internal _v3SwapRouter;

    function setUp() public override {
        super.setUp();

        _deployUniV3Minter();
        _deployWETH();
        _deployTokens();
        _deployPEAS();
        _deployUniV2();
        _deployUniV3();
        _deployProtocolFees();
        _deployRewardsWhitelist();
        _deployTwapUtils();
        _deployDexAdapter();
        _deployIndexUtils();
        _deployWeightedIndexes();
        _deployAutoCompoundingPodLpFactory();
        _getAutoCompoundingPodLpAddresses();
        _deployAspTKNOracles();
        _deployAspTKNs();
        _deployVariableInterestRate();
        _deployFraxWhitelist();
        _deployFraxPairRegistry();
        _deployFraxPairDeployer();
        _deployFraxPairs();
        _deployLendingAssetVault();
        _deployLeverageManager();
        _deployFlashSources();
        
        _mockDai.mint(alice, 1_000_000 ether);
        _mockDai.mint(bob, 1_000_000 ether);
        _mockDai.mint(charlie, 1_000_000 ether);
        _peas.transfer(alice, 100_000 ether);
        _peas.transfer(bob, 100_000 ether);
        _peas.transfer(charlie, 100_000 ether);
    }

    function _deployUniV3Minter() internal {
        _uniV3Minter = new MockUniV3Minter();
    }

    function _deployWETH() internal {
        _weth = new WETH9();

        vm.deal(address(this), 1_000_000 ether);
        _weth.deposit{value: 1_000_000 ether}();

        vm.deal(address(_uniV3Minter), 2_000_000 ether);
        vm.prank(address(_uniV3Minter));
        _weth.deposit{value: 2_000_000 ether}();
    }

    function _deployTokens() internal {
        _mockDai = new MockERC20();
        _tokenA = new MockERC20();
        _tokenB = new MockERC20();
        _tokenC = new MockERC20();

        _mockDai.initialize("MockDAI", "mDAI", 18);
        _tokenA.initialize("TokenA", "TA", 18);
        _tokenB.initialize("TokenB", "TB", 18);
        _tokenC.initialize("TokenC", "TC", 18);

        _tokenA.mint(address(this), 1_000_000 ether);
        _tokenB.mint(address(this), 1_000_000 ether);
        _tokenC.mint(address(this), 1_000_000 ether);
        _mockDai.mint(address(this), 1_000_000 ether);

        _tokenA.mint(address(_uniV3Minter), 1_000_000 ether);
        _tokenB.mint(address(_uniV3Minter), 1_000_000 ether);
        _tokenC.mint(address(_uniV3Minter), 1_000_000 ether);
        _mockDai.mint(address(_uniV3Minter), 1_000_000 ether);

        _tokenA.mint(alice, 1_000_000 ether);
        _tokenB.mint(alice, 1_000_000 ether);
        _tokenC.mint(alice, 1_000_000 ether);
        _mockDai.mint(alice, 1_000_000 ether);

        _tokenA.mint(bob, 1_000_000 ether);
        _tokenB.mint(bob, 1_000_000 ether);
        _tokenC.mint(bob, 1_000_000 ether);
        _mockDai.mint(bob, 1_000_000 ether);

        _tokenA.mint(charlie, 1_000_000 ether);
        _tokenB.mint(charlie, 1_000_000 ether);
        _tokenC.mint(charlie, 1_000_000 ether);
        _mockDai.mint(charlie, 1_000_000 ether);
    }

    function _deployPEAS() internal {
        _peas = new PEAS("Peapods", "PEAS");
        _peas.transfer(address(_uniV3Minter), 2_000_000 ether);
    }

    function _deployUniV2() internal {
        _uniV2Factory = new UniswapV2Factory(address(this));
        _v2SwapRouter = new UniswapV2Router02(address(_uniV2Factory), address(_weth));
    }

    function _deployUniV3() internal {
        _uniV3Factory = new UniswapV3Factory();
        _v3peasDaiPool = UniswapV3Pool(_uniV3Factory.createPool(address(_peas), address(_mockDai), 10_000));
        _v3peasDaiPool.initialize(1 << 96);
        _v3peasDaiPool.increaseObservationCardinalityNext(600);
        _uniV3Minter.V3addLiquidity(_v3peasDaiPool, 100_000 ether);

        _v3peasDaiFlash = UniswapV3Pool(_uniV3Factory.createPool(address(_peas), address(_mockDai), 500));
        _v3peasDaiFlash.initialize(1 << 96);
        _v3peasDaiFlash.increaseObservationCardinalityNext(600);
        _uniV3Minter.V3addLiquidity(_v3peasDaiFlash, 100_000e18);

        _v3SwapRouter = new SwapRouter02(address(_uniV2Factory), address(_uniV3Factory), address(0), address(_weth));
    }

    function _deployProtocolFees() internal {
        _protocolFees = new ProtocolFees();
        _protocolFees.setYieldAdmin(500);
        _protocolFees.setYieldBurn(500);

        _protocolFeeRouter = new ProtocolFeeRouter(_protocolFees);
        bytes memory code = address(_protocolFeeRouter).code;
        vm.etch(0x7d544DD34ABbE24C8832db27820Ff53C151e949b, code);
        _protocolFeeRouter = ProtocolFeeRouter(0x7d544DD34ABbE24C8832db27820Ff53C151e949b);

        vm.prank(_protocolFeeRouter.owner());
        _protocolFeeRouter.transferOwnership(address(this));
        _protocolFeeRouter.setProtocolFees(_protocolFees);
    }

    function _deployRewardsWhitelist() internal {
        _rewardsWhitelist = new RewardsWhitelist();
        bytes memory code = address(_rewardsWhitelist).code;
        vm.etch(0xEc0Eb48d2D638f241c1a7F109e38ef2901E9450F, code);
        _rewardsWhitelist = RewardsWhitelist(0xEc0Eb48d2D638f241c1a7F109e38ef2901E9450F);

        vm.prank(_rewardsWhitelist.owner());
        _rewardsWhitelist.transferOwnership(address(this));
        _rewardsWhitelist.toggleRewardsToken(address(_peas), true);
    }

    function _deployTwapUtils() internal {
        _twapUtils = new MockV3TwapUtilities();
        bytes memory code = address(_twapUtils).code;
        vm.etch(0x024ff47D552cB222b265D68C7aeB26E586D5229D, code);
        _twapUtils = MockV3TwapUtilities(0x024ff47D552cB222b265D68C7aeB26E586D5229D);
    }

    function _deployDexAdapter() internal {
        _dexAdapter = new UniswapDexAdapter(_twapUtils, address(_v2SwapRouter), address(_v3SwapRouter), false);
    }

    function _deployIndexUtils() internal {
        _indexUtils = new IndexUtils(_twapUtils, _dexAdapter);
    }

    function _deployWeightedIndexes() internal {
        IDecentralizedIndex.Config memory _c;
        IDecentralizedIndex.Fees memory _f;
        _f.bond = 300;
        _f.debond = 300;
        _f.burn = 5000;
        _f.buy = 200;
        _f.sell = 200;

        // POD1 (Peas)
        address[] memory _t1 = new address[](1);
        _t1[0] = address(_peas);
        uint256[] memory _w1 = new uint256[](1);
        _w1[0] = 100;
        address __pod1Peas = _createPod(
            "Peas Pod",
            "pPeas",
            _c,
            _f,
            _t1,
            _w1,
            address(0),
            false,
            abi.encode(
                address(_mockDai),
                address(_peas),
                address(_mockDai),
                address(_protocolFeeRouter),
                address(_rewardsWhitelist),
                address(_twapUtils),
                address(_dexAdapter)
            )
        );
        _pod1Peas = WeightedIndex(payable(__pod1Peas));

        _peas.approve(address(_pod1Peas), 10000 ether);
        _mockDai.approve(address(_pod1Peas), 10000 ether);
        _pod1Peas.bond(address(_peas), 10000 ether, 1 ether);
        _pod1Peas.addLiquidityV2(10000 ether, 10000 ether, 100, block.timestamp);
    }

    function _deployAutoCompoundingPodLpFactory() internal {
        _aspTKNFactory = new AutoCompoundingPodLpFactory();
    }
    
    function _getAutoCompoundingPodLpAddresses() internal {
        _aspTKN1PeasAddress = _aspTKNFactory.getNewCaFromParams(
            "Test aspTKN1Peas", "aspTKN1Peas", false, _pod1Peas, _dexAdapter, _indexUtils, 0
        );
    }

    function _deployAspTKNOracles() internal {
        _v2Res = new V2ReservesUniswap();
        _clOracle = new ChainlinkSinglePriceOracle(address(0));
        _uniOracle = new UniswapV3SinglePriceOracle(address(0));
        _diaOracle = new DIAOracleV2SinglePriceOracle(address(0));

        _aspTKNMinOracle1Peas = new aspTKNMinimalOracle(
            address(_aspTKN1PeasAddress),
            abi.encode(
                address(_clOracle),
                address(_uniOracle),
                address(_diaOracle),
                address(_mockDai),
                false,
                false,
                _pod1Peas.lpStakingPool(),
                address(_v3peasDaiPool)
            ),
            abi.encode(address(0), address(0), address(0), address(0), address(0), address(_v2Res))
        );
    }

    function _deployAspTKNs() internal {
        //POD 1
        address _lpPeas = _pod1Peas.lpStakingPool();
        address _stakingPeas = StakingPoolToken(_lpPeas).stakingToken();

        IERC20(_stakingPeas).approve(_lpPeas, 1000);
        StakingPoolToken(_lpPeas).stake(address(this), 1000);
        IERC20(_lpPeas).approve(address(_aspTKNFactory), 1000);

        _aspTKNFactory.create("Test aspTKN1Peas", "aspTKN1Peas", false, _pod1Peas, _dexAdapter, _indexUtils, 0);
        _aspTKN1Peas = AutoCompoundingPodLp(_aspTKN1PeasAddress);
    }

    function _deployVariableInterestRate() internal {
        _variableInterestRate = new VariableInterestRate(
            "[0.5 0.2@.875 5-10k] 2 days (.75-.85)",
            87500,
            200000000000000000,
            75000,
            85000,
            158247046,
            1582470460,
            3164940920000,
            172800
        );
    }

    function _deployFraxWhitelist() internal {
        _fraxWhitelist = new FraxlendWhitelist();
    }

    function _deployFraxPairRegistry() internal {
        address[] memory _initialDeployers = new address[](0);
        _fraxRegistry = new FraxlendPairRegistry(address(this), _initialDeployers);
    }

    function _deployFraxPairDeployer() internal {
        ConstructorParams memory _params =
            ConstructorParams(circuitBreaker, comptroller, timelock, address(_fraxWhitelist), address(_fraxRegistry));
        _fraxDeployer = new FraxlendPairDeployer(_params);

        _fraxDeployer.setCreationCode(type(FraxlendPair).creationCode);

        address[] memory _whitelistDeployer = new address[](1);
        _whitelistDeployer[0] = address(this);

        _fraxWhitelist.setFraxlendDeployerWhitelist(_whitelistDeployer, true);

        address[] memory _registryDeployer = new address[](1);
        _registryDeployer[0] = address(_fraxDeployer);

        _fraxRegistry.setDeployers(_registryDeployer, true);
    }

    function _deployFraxPairs() internal {
        vm.warp(block.timestamp + 1 days);

        _fraxLPToken1Peas = FraxlendPair(
            _fraxDeployer.deploy(
                abi.encode(
                    _pod1Peas.PAIRED_LP_TOKEN(), // asset
                    _aspTKN1PeasAddress, // collateral
                    address(_aspTKNMinOracle1Peas), //oracle
                    5000, // maxOracleDeviation
                    address(_variableInterestRate), //rateContract
                    1000, //fullUtilizationRate
                    75000, // maxLtv
                    10000, // uint256 _cleanLiquidationFee
                    9000, // uint256 _dirtyLiquidationFee
                    2000 //uint256 _protocolLiquidationFee
                )
            )
        );
    }

    function _deployLendingAssetVault() internal {
        _lendingAssetVault = new LendingAssetVault("Test LAV", "tLAV", address(_mockDai));
        IERC20 vaultAsset1Peas = IERC20(_fraxLPToken1Peas.asset());
        vaultAsset1Peas.approve(address(_fraxLPToken1Peas), vaultAsset1Peas.totalSupply());
        vaultAsset1Peas.approve(address(_lendingAssetVault), vaultAsset1Peas.totalSupply());
        _lendingAssetVault.setVaultWhitelist(address(_fraxLPToken1Peas), true);

        address[] memory _vaults = new address[](1);
        _vaults[0] = address(_fraxLPToken1Peas);
        uint256[] memory _allocations = new uint256[](1);
        _allocations[0] = 100_000e18;
        _lendingAssetVault.setVaultMaxAllocation(_vaults, _allocations);

        vm.prank(timelock);
        _fraxLPToken1Peas.setExternalAssetVault(IERC4626Extended(address(_lendingAssetVault)));
    }

    function _deployLeverageManager() internal {
        _leverageManager = new LeverageManager("Test LM", "tLM", IIndexUtils(address(_indexUtils)));
        _leverageManager.setLendingPair(address(_pod1Peas), address(_fraxLPToken1Peas));
    }

    function _deployFlashSources() internal {
        _uniswapV3FlashSourcePeas = new UniswapV3FlashSource(address(_v3peasDaiFlash), address(_leverageManager));
        _leverageManager.setFlashSource(address(_pod1Peas.PAIRED_LP_TOKEN()), address(_uniswapV3FlashSourcePeas));
    }

    function testPoc() public { //sell fee is set in line 334
        vm.startPrank(bob);
        console.log("\n====== Bob deposits 5000 _mockDai in fraxlend ======");
        _mockDai.approve(address(_fraxLPToken1Peas), 5000e18);
        _fraxLPToken1Peas.deposit(5000e18, bob);
        vm.stopPrank();

        vm.startPrank(alice);
        console.log("\n====== Alice bonds 5000 Peas ======");
        _peas.approve(address(_pod1Peas), 5000e18);
        _pod1Peas.bond(address(_peas), 5000e18, 0);

        console.log("\n====== Alice adds leverage ======");
        _pod1Peas.approve(address(_leverageManager), 4850e18);
        _leverageManager.addLeverage(
            0,
            address(_pod1Peas),
            4850e18,
            4850e18,
            0,
            false,
            abi.encode(0, 1000, block.timestamp)
        );
        
        console.log("\n====== Alice removes leverage ======");
        _leverageManager.removeLeverage( //This will be reverted with the UniswapV2: K error because fee-on-transfer is not supported
            1,
            4852425000000000000000,
            _aspTKN1Peas.balanceOf(address(_fraxLPToken1Peas)),
            0,
            0,
            0,
            0
        );
        vm.stopPrank();
    }
}
```
3. The POC can then be started with `forge test --mt testPoc -vv --fork-url <FORK_URL>`

### Mitigation

_No response_