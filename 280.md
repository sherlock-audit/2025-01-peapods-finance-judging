Witty Chartreuse Starling

Medium

# Self-lending does not work unless someone has deposited into the lending pair beforehand, as the flash loan fees are not taken into account when borrowing during self-lending

### Summary

If `addLeverage` is called with self-lending in the `LeverageManager`, it must revert if no assets have been deposited into the lending pair yet. This is because, when borrowing, the flash loan fees cause more to be borrowed than was deposited through self-lending. As a result, self-lending would not serve its intended purpose properly, since one would have to wait for another depositor to deposit enough to cover the flash loan fees.

### Root Cause

Self-lending was built so that no depositors are needed who first have to deposit before borrowing can take place. Instead, the first users can simply leverage their pTKNs without a depositor and lend to themselves in the process, allowing the pod to get started. This was clearly described here under "The Chicken-and-egg issue": https://medium.com/@peapodsfinance/self-lending-pods-8ff8625bb878.
https://github.com/sherlock-audit/2025-01-peapods-finance/blob/main/contracts/contracts/lvf/LeverageManager.sol#L522-L532
Here you can see the function that deposits into the lending pair during self-lending. You can also see that only the `_borrowAmt` is deposited.
The problem with this is that later in the function, the borrow amount plus the flash loan fees are borrowed:
https://github.com/sherlock-audit/2025-01-peapods-finance/blob/main/contracts/contracts/lvf/LeverageManager.sol#L328-L329
This cannot work because the amount for the flash loan fees was never deposited.

### Internal Pre-conditions

No internal pre conditions

### External Pre-conditions

1. This issue is only a problem if not enough has been deposited by external depositors to cover the flash loan fees

### Attack Path

1. Alice bonds her peas in a pod
2. For this pod, self-lending is set up
3. Alice wants to get the pod started and calls addLeverage because of that
4. The call reverts because the flashloan fees is not taken into account

### Impact

The basic idea of self-lending pods doesn't work entirely due to the issue that depositors are still needed to ensure there are enough assets to cover the flash loan fees. Until then, a pod cannot be started with self-lending.

### PoC

1. To execute the POC, a POC.t.sol file should be created in contracts/test/POC.t.sol.
2. The following code should be inserted into the file:
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import {console} from "forge-std/console.sol";

// forge
import {Test} from "forge-std/Test.sol";

// PEAS
import {PEAS} from "../../contracts/PEAS.sol";
import {V3TwapUtilities} from "../../contracts/twaputils/V3TwapUtilities.sol";
import {UniswapDexAdapter} from "../../contracts/dex/UniswapDexAdapter.sol";
import {IDecentralizedIndex} from "../../contracts/interfaces/IDecentralizedIndex.sol";
import {WeightedIndex} from "../../contracts/WeightedIndex.sol";
import {StakingPoolToken} from "../../contracts/StakingPoolToken.sol";
import {LendingAssetVault} from "../../contracts/LendingAssetVault.sol";
import {IndexUtils} from "../../contracts/IndexUtils.sol";
import {IIndexUtils} from "../../contracts/interfaces/IIndexUtils.sol";
import {IndexUtils} from "../contracts/IndexUtils.sol";
import {RewardsWhitelist} from "../../contracts/RewardsWhitelist.sol";
import {TokenRewards} from "../../contracts/TokenRewards.sol";

// oracles
import {ChainlinkSinglePriceOracle} from "../../contracts/oracle/ChainlinkSinglePriceOracle.sol";
import {UniswapV3SinglePriceOracle} from "../../contracts/oracle/UniswapV3SinglePriceOracle.sol";
import {DIAOracleV2SinglePriceOracle} from "../../contracts/oracle/DIAOracleV2SinglePriceOracle.sol";
import {V2ReservesUniswap} from "../../contracts/oracle/V2ReservesUniswap.sol";
import {aspTKNMinimalOracle} from "../../contracts/oracle/aspTKNMinimalOracle.sol";

// protocol fees
import {ProtocolFees} from "../../contracts/ProtocolFees.sol";
import {ProtocolFeeRouter} from "../../contracts/ProtocolFeeRouter.sol";

// autocompounding
import {AutoCompoundingPodLpFactory} from "../../contracts/AutoCompoundingPodLpFactory.sol";
import {AutoCompoundingPodLp} from "../../contracts/AutoCompoundingPodLp.sol";

// lvf
import {LeverageManager} from "../../contracts/lvf/LeverageManager.sol";

// fraxlend
import {FraxlendPairDeployer, ConstructorParams} from "./invariant/modules/fraxlend/FraxlendPairDeployer.sol";
import {FraxlendWhitelist} from "./invariant/modules/fraxlend/FraxlendWhitelist.sol";
import {FraxlendPairRegistry} from "./invariant/modules/fraxlend/FraxlendPairRegistry.sol";
import {FraxlendPair} from "./invariant/modules/fraxlend/FraxlendPair.sol";
import {VariableInterestRate} from "./invariant/modules/fraxlend/VariableInterestRate.sol";
import {IERC4626Extended} from "./invariant/modules/fraxlend/interfaces/IERC4626Extended.sol";

// flash
import {IVault} from "./invariant/modules/balancer/interfaces/IVault.sol";
import {BalancerFlashSource} from "../../contracts/flash/BalancerFlashSource.sol";
import {PodFlashSource} from "../../contracts/flash/PodFlashSource.sol";
import {UniswapV3FlashSource} from "../../contracts/flash/UniswapV3FlashSource.sol";

// uniswap-v2-core
import {UniswapV2Factory} from "v2-core/UniswapV2Factory.sol";
import {UniswapV2Pair} from "v2-core/UniswapV2Pair.sol";

// uniswap-v2-periphery
import {UniswapV2Router02} from "v2-periphery/UniswapV2Router02.sol";

// uniswap-v3-core
import {UniswapV3Factory} from "v3-core/UniswapV3Factory.sol";
import {UniswapV3Pool} from "v3-core/UniswapV3Pool.sol";

// uniswap-v3-periphery
import {SwapRouter02} from "swap-router/SwapRouter02.sol";
import {LiquidityManagement} from "v3-periphery/base/LiquidityManagement.sol";
import {PeripheryPayments} from "v3-periphery/base/PeripheryPayments.sol";
import {PoolAddress} from "v3-periphery/libraries/PoolAddress.sol";

// mocks
import {WETH9} from "./invariant/mocks/WETH.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {MockERC20} from "./invariant/mocks/MockERC20.sol";
import {TestERC20} from "./invariant/mocks/TestERC20.sol";
import {TestERC4626Vault} from "./invariant/mocks/TestERC4626Vault.sol";
import {MockV3Aggregator} from "./invariant/mocks/MockV3Aggregator.sol";
import {MockUniV3Minter} from "./invariant/mocks/MockUniV3Minter.sol";
import {MockV3TwapUtilities} from "./invariant/mocks/MockV3TwapUtilities.sol";

import {PodHelperTest} from "./helpers/PodHelper.t.sol";

contract MockOracle {
    uint256 public priceLow;
    uint256 public priceHigh;

    function setPriceLow(uint256 _priceLow) public {
        priceLow = _priceLow;
    }

    function setPriceHigh(uint256 _priceHigh) public {
        priceHigh = _priceHigh;
    }
    
    function getPrices()
        public
        view
        returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh)
    {
        _isBadData = false;
        _priceLow = priceLow;
        _priceHigh = priceHigh;
    }
}

contract AuditTests is PodHelperTest {
    address alice = vm.addr(uint256(keccak256("alice")));
    address bob = vm.addr(uint256(keccak256("bob")));
    address charlie = vm.addr(uint256(keccak256("charlie")));

    uint256[] internal _fraxPercentages = [10000, 2500, 7500, 5000];

    // fraxlend protocol actors
    address internal comptroller = vm.addr(uint256(keccak256("comptroller")));
    address internal circuitBreaker = vm.addr(uint256(keccak256("circuitBreaker")));
    address internal timelock = vm.addr(uint256(keccak256("comptroller")));

    uint16 internal fee = 100;
    uint256 internal PRECISION = 10 ** 27;

    uint256 donatedAmount;
    uint256 lavDeposits;

    /*///////////////////////////////////////////////////////////////
                            TEST CONTRACTS
    ///////////////////////////////////////////////////////////////*/

    PEAS internal _peas;
    MockV3TwapUtilities internal _twapUtils;
    UniswapDexAdapter internal _dexAdapter;
    LendingAssetVault internal _lendingAssetVault;
    LendingAssetVault internal _lendingAssetVault2;
    RewardsWhitelist internal _rewardsWhitelist;

    // oracles
    V2ReservesUniswap internal _v2Res;
    ChainlinkSinglePriceOracle internal _clOracle;
    UniswapV3SinglePriceOracle internal _uniOracle;
    DIAOracleV2SinglePriceOracle internal _diaOracle;
    aspTKNMinimalOracle internal _aspTKNMinOracle3;
    aspTKNMinimalOracle internal _aspTKNMinOracle4;
    MockOracle internal _mockOracle;

    // protocol fees
    ProtocolFees internal _protocolFees;
    ProtocolFeeRouter internal _protocolFeeRouter;

    // pods
    WeightedIndex internal _pod1Peas; // 1 token (Peas)
    WeightedIndex internal _pod1Weth; // 1 token (Weth)
    WeightedIndex internal _pod2; // 2 tokens
    WeightedIndex internal _pod3;
    WeightedIndex internal _pod4; // 4 tokens *_*

    WeightedIndex[] internal _pods;

    // index utils
    IndexUtils internal _indexUtils;

    // autocompounding
    AutoCompoundingPodLpFactory internal _aspTKNFactory;
    AutoCompoundingPodLp internal _aspTKN3;
    address internal _aspTKN3Address;
    AutoCompoundingPodLp internal _aspTKN4;
    address internal _aspTKN4Address;

    AutoCompoundingPodLp[] internal _aspTKNs;

    // lvf
    LeverageManager internal _leverageManager;

    // fraxlend
    FraxlendPairDeployer internal _fraxDeployer;
    FraxlendWhitelist internal _fraxWhitelist;
    FraxlendPairRegistry internal _fraxRegistry;
    VariableInterestRate internal _variableInterestRate;

    FraxlendPair internal _fraxLPToken3;
    FraxlendPair internal _fraxLPToken4;

    FraxlendPair[] internal _fraxPairs;

    // flash
    UniswapV3FlashSource internal _uniswapV3FlashSourcePeas;
    UniswapV3FlashSource internal _uniswapV3FlashSourceWeth;

    // mocks
    MockUniV3Minter internal _uniV3Minter;
    MockERC20 internal _mockDai;
    WETH9 internal _weth;
    MockERC20 internal _tokenA;
    MockERC20 internal _tokenB;
    MockERC20 internal _tokenC;

    // uniswap-v2-core
    UniswapV2Factory internal _uniV2Factory;
    UniswapV2Pair internal _uniV2Pool;

    // uniswap-v2-periphery
    UniswapV2Router02 internal _v2SwapRouter;

    // uniswap-v3-core
    UniswapV3Factory internal _uniV3Factory;
    UniswapV3Pool internal _v3peasDaiPool;
    UniswapV3Pool internal _v3peasDaiFlash;
    UniswapV3Pool internal _v3wethDaiFlash;
    UniswapV3Pool internal _v3wethDaiPool;
    UniswapV3Pool internal _v3TokenATokenBPool;

    // uniswap-v3-periphery
    SwapRouter02 internal _v3SwapRouter;

    function setUp() public override {
        super.setUp();

        _deployUniV3Minter();
        _deployWETH();
        _deployTokens();
        _deployPEAS();
        _deployUniV2();
        _deployUniV3();
        _deployProtocolFees();
        _deployRewardsWhitelist();
        _deployTwapUtils();
        _deployDexAdapter();
        _deployIndexUtils();
        _deployAutoCompoundingPodLpFactory();
        _deployAspTKNOracles();
        _deployVariableInterestRate();
        _deployFraxWhitelist();
        _deployFraxPairRegistry();
        _deployFraxPairDeployer();
        _deployLendingAssetVault();
        _deployLeverageManager();
        _deployFlashSources();
        
        _mockDai.mint(alice, 1_000_000 ether);
        _mockDai.mint(bob, 1_000_000 ether);
        _mockDai.mint(charlie, 1_000_000 ether);
        _peas.transfer(alice, 100_000 ether);
        _peas.transfer(bob, 100_000 ether);
        _peas.transfer(charlie, 100_000 ether);
    }

    function _deployUniV3Minter() internal {
        _uniV3Minter = new MockUniV3Minter();
    }

    function _deployWETH() internal {
        _weth = new WETH9();

        vm.deal(address(this), 1_000_000 ether);
        _weth.deposit{value: 1_000_000 ether}();

        vm.deal(address(_uniV3Minter), 2_000_000 ether);
        vm.prank(address(_uniV3Minter));
        _weth.deposit{value: 2_000_000 ether}();
    }

    function _deployTokens() internal {
        _mockDai = new MockERC20();
        _tokenA = new MockERC20();
        _tokenB = new MockERC20();
        _tokenC = new MockERC20();

        _mockDai.initialize("MockDAI", "mDAI", 18);
        _tokenA.initialize("TokenA", "TA", 18);
        _tokenB.initialize("TokenB", "TB", 18);
        _tokenC.initialize("TokenC", "TC", 18);

        _tokenA.mint(address(this), 1_000_000 ether);
        _tokenB.mint(address(this), 1_000_000 ether);
        _tokenC.mint(address(this), 1_000_000 ether);
        _mockDai.mint(address(this), 1_000_000 ether);

        _tokenA.mint(address(_uniV3Minter), 1_000_000 ether);
        _tokenB.mint(address(_uniV3Minter), 1_000_000 ether);
        _tokenC.mint(address(_uniV3Minter), 1_000_000 ether);
        _mockDai.mint(address(_uniV3Minter), 1_000_000 ether);

        _tokenA.mint(alice, 1_000_000 ether);
        _tokenB.mint(alice, 1_000_000 ether);
        _tokenC.mint(alice, 1_000_000 ether);
        _mockDai.mint(alice, 1_000_000 ether);

        _tokenA.mint(bob, 1_000_000 ether);
        _tokenB.mint(bob, 1_000_000 ether);
        _tokenC.mint(bob, 1_000_000 ether);
        _mockDai.mint(bob, 1_000_000 ether);

        _tokenA.mint(charlie, 1_000_000 ether);
        _tokenB.mint(charlie, 1_000_000 ether);
        _tokenC.mint(charlie, 1_000_000 ether);
        _mockDai.mint(charlie, 1_000_000 ether);
    }

    function _deployPEAS() internal {
        _peas = new PEAS("Peapods", "PEAS");
        _peas.transfer(address(_uniV3Minter), 2_000_000 ether);
    }

    function _deployUniV2() internal {
        _uniV2Factory = new UniswapV2Factory(address(this));
        _v2SwapRouter = new UniswapV2Router02(address(_uniV2Factory), address(_weth));
    }

    function _deployUniV3() internal {
        _uniV3Factory = new UniswapV3Factory();
        _v3peasDaiPool = UniswapV3Pool(_uniV3Factory.createPool(address(_peas), address(_mockDai), 10_000));
        _v3peasDaiPool.initialize(1 << 96);
        _v3peasDaiPool.increaseObservationCardinalityNext(600);
        _uniV3Minter.V3addLiquidity(_v3peasDaiPool, 100_000 ether);

        _v3peasDaiFlash = UniswapV3Pool(_uniV3Factory.createPool(address(_peas), address(_mockDai), 500));
        _v3peasDaiFlash.initialize(1 << 96);
        _v3peasDaiFlash.increaseObservationCardinalityNext(600);
        _uniV3Minter.V3addLiquidity(_v3peasDaiFlash, 100_000e18);

        _v3SwapRouter = new SwapRouter02(address(_uniV2Factory), address(_uniV3Factory), address(0), address(_weth));
    }

    function _deployProtocolFees() internal {
        _protocolFees = new ProtocolFees();
        _protocolFees.setYieldAdmin(500);
        _protocolFees.setYieldBurn(500);

        _protocolFeeRouter = new ProtocolFeeRouter(_protocolFees);
        bytes memory code = address(_protocolFeeRouter).code;
        vm.etch(0x7d544DD34ABbE24C8832db27820Ff53C151e949b, code);
        _protocolFeeRouter = ProtocolFeeRouter(0x7d544DD34ABbE24C8832db27820Ff53C151e949b);

        vm.prank(_protocolFeeRouter.owner());
        _protocolFeeRouter.transferOwnership(address(this));
        _protocolFeeRouter.setProtocolFees(_protocolFees);
    }

    function _deployRewardsWhitelist() internal {
        _rewardsWhitelist = new RewardsWhitelist();
        bytes memory code = address(_rewardsWhitelist).code;
        vm.etch(0xEc0Eb48d2D638f241c1a7F109e38ef2901E9450F, code);
        _rewardsWhitelist = RewardsWhitelist(0xEc0Eb48d2D638f241c1a7F109e38ef2901E9450F);

        vm.prank(_rewardsWhitelist.owner());
        _rewardsWhitelist.transferOwnership(address(this));
        _rewardsWhitelist.toggleRewardsToken(address(_peas), true);
    }

    function _deployTwapUtils() internal {
        _twapUtils = new MockV3TwapUtilities();
        bytes memory code = address(_twapUtils).code;
        vm.etch(0x024ff47D552cB222b265D68C7aeB26E586D5229D, code);
        _twapUtils = MockV3TwapUtilities(0x024ff47D552cB222b265D68C7aeB26E586D5229D);
    }

    function _deployDexAdapter() internal {
        _dexAdapter = new UniswapDexAdapter(_twapUtils, address(_v2SwapRouter), address(_v3SwapRouter), false);
    }

    function _deployIndexUtils() internal {
        _indexUtils = new IndexUtils(_twapUtils, _dexAdapter);
    }

    function _deployAutoCompoundingPodLpFactory() internal {
        _aspTKNFactory = new AutoCompoundingPodLpFactory();
    }

    function _deployAspTKNOracles() internal {
        _v2Res = new V2ReservesUniswap();
        _clOracle = new ChainlinkSinglePriceOracle(address(0));
        _uniOracle = new UniswapV3SinglePriceOracle(address(0));
        _diaOracle = new DIAOracleV2SinglePriceOracle(address(0));
    }

    function _deployVariableInterestRate() internal {
        _variableInterestRate = new VariableInterestRate(
            "[0.5 0.2@.875 5-10k] 2 days (.75-.85)",
            87500,
            200000000000000000,
            75000,
            85000,
            158247046,
            1582470460,
            3164940920000,
            172800
        );
    }

    function _deployFraxWhitelist() internal {
        _fraxWhitelist = new FraxlendWhitelist();
    }

    function _deployFraxPairRegistry() internal {
        address[] memory _initialDeployers = new address[](0);
        _fraxRegistry = new FraxlendPairRegistry(address(this), _initialDeployers);
    }

    function _deployFraxPairDeployer() internal {
        ConstructorParams memory _params =
            ConstructorParams(circuitBreaker, comptroller, timelock, address(_fraxWhitelist), address(_fraxRegistry));
        _fraxDeployer = new FraxlendPairDeployer(_params);

        _fraxDeployer.setCreationCode(type(FraxlendPair).creationCode);

        address[] memory _whitelistDeployer = new address[](1);
        _whitelistDeployer[0] = address(this);

        _fraxWhitelist.setFraxlendDeployerWhitelist(_whitelistDeployer, true);

        address[] memory _registryDeployer = new address[](1);
        _registryDeployer[0] = address(_fraxDeployer);

        _fraxRegistry.setDeployers(_registryDeployer, true);
    }

    function _deployLendingAssetVault() internal {
        _lendingAssetVault = new LendingAssetVault("Test LAV", "tLAV", address(_mockDai));
    }

    function _deployLeverageManager() internal {
        _leverageManager = new LeverageManager("Test LM", "tLM", IIndexUtils(address(_indexUtils)));
    }

    function _deployFlashSources() internal {
        _uniswapV3FlashSourcePeas = new UniswapV3FlashSource(address(_v3peasDaiFlash), address(_leverageManager));
        _leverageManager.setFlashSource(address(_mockDai), address(_uniswapV3FlashSourcePeas));
    }

    function _setupSelfLending() public {
        _aspTKN3Address = _aspTKNFactory.getNewCaFromParams(
            "Test aspTKN3", "aspTKN3", true, IDecentralizedIndex(address(0)), _dexAdapter, _indexUtils, 0
        );

        _mockOracle = new MockOracle();
        _mockOracle.setPriceLow(0.5e18);
        _mockOracle.setPriceHigh(0.5e18);
        
        _fraxLPToken3 = FraxlendPair(
            _fraxDeployer.deploy(
                abi.encode(
                    address(_mockDai), // asset
                    _aspTKN3Address, // collateral
                    address(_mockOracle), //oracle
                    5000, // maxOracleDeviation
                    address(_variableInterestRate), //rateContract
                    1000, //fullUtilizationRate
                    75000, // maxLtv
                    10000, // uint256 _cleanLiquidationFee
                    9000, // uint256 _dirtyLiquidationFee
                    2000 //uint256 _protocolLiquidationFee
                )
            )
        );


        IDecentralizedIndex.Config memory _c;
        IDecentralizedIndex.Fees memory _f;
        _f.bond = 300;
        _f.debond = 300;
        _f.burn = 500;
        _f.buy = 200;

        address[] memory _t1 = new address[](1);
        _t1[0] = address(_fraxLPToken3);
        uint256[] memory _w1 = new uint256[](1);
        _w1[0] = 100;
        address __pod4 = _createPod(
            "fDai Pod",
            "pfDai",
            _c,
            _f,
            _t1,
            _w1,
            address(0),
            false,
            abi.encode(
                address(_mockDai),
                address(_peas),
                address(_mockDai),
                address(_protocolFeeRouter),
                address(_rewardsWhitelist),
                address(_twapUtils),
                address(_dexAdapter)
            )
        );
        _pod4 = WeightedIndex(payable(__pod4));

        _t1[0] = address(_tokenA);
        _w1[0] = 100;
        address __pod3 = _createPod(
            "TokenA Pod",
            "pTokenA",
            _c,
            _f,
            _t1,
            _w1,
            address(0),
            false,
            abi.encode(
                address(_pod4),
                address(_peas),
                address(_mockDai),
                address(_protocolFeeRouter),
                address(_rewardsWhitelist),
                address(_twapUtils),
                address(_dexAdapter)
            )
        );
        _pod3 = WeightedIndex(payable(__pod3));

        _aspTKNFactory.setMinimumDepositAtCreation(0);

        _aspTKNFactory.create("Test aspTKN3", "aspTKN3", true, IDecentralizedIndex(address(0)), _dexAdapter, _indexUtils, 0);
        _aspTKN3 = AutoCompoundingPodLp(_aspTKN3Address);
        _aspTKN3.setPod(_pod3);

        _leverageManager.setLendingPair(address(_pod3), address(_fraxLPToken3));

        _lendingAssetVault.setVaultWhitelist(address(_fraxLPToken3), true);

        address[] memory _vaults = new address[](1);
        _vaults[0] = address(_fraxLPToken3);
        uint256[] memory _allocations = new uint256[](1);
        _allocations[0] = 100_000e18;
        _lendingAssetVault.setVaultMaxAllocation(_vaults, _allocations);

        vm.prank(timelock);
        _fraxLPToken3.setExternalAssetVault(IERC4626Extended(address(_lendingAssetVault)));
    }

    function testPoc() public {
        _setupSelfLending();

        vm.startPrank(alice);
        console.log("\n====== Alice bonds 10_000 TokenA ======");
        _tokenA.approve(address(_pod3), 10_000e18);
        _pod3.bond(address(_tokenA), 10_000e18, 0);

        console.log("\n====== Alice addLeverage 10_000 pTKN ======");
        _pod3.approve(address(_leverageManager), 10_000e18);
        _leverageManager.addLeverage(
            0,
            address(_pod3),
            10_000e18,
            10_000e18,
            0,
            true,
            abi.encode(0, 1000, block.timestamp)
        );
        vm.stopPrank();
    }
}
```
The POC can then be started with `forge test --mt testPoc -vv --fork-url <FORK_URL>`
The POC should revert with the following error, indicating that there are not enough tokens available to borrow in the lending pair:
```solidity
[FAIL: InsufficientAssetsInContract(10000000000000000000000 [1e22], 10005000000000000000000 [1e22])]
```

### Mitigation

_No response_